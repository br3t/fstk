<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8" />
	<title>Основы JavaScript 3. Массивы@ Курс Frontend-разработки</title>
	<link rel="stylesheet" type="text/css" href="../../css/style.css" />
	<style>
		.methods {
			border: 1px solid #000;
			border-collapse: collapse;
			width: 100%;
		}
		.methods tr:nth-child(2n) {
			background: #FFF;
		}
		.methods td,
		.methods th {
			border: 1px solid #000;
			padding: 5px 7px;
			text-align: left;
			vertical-align: top;
		}
		.methods th {
			width: 400px;
			font-family: Menlo, "Lucida Sans Typewriter", monospace;;
		}
	</style>
</head>
<body>
	<h1>Основы JavaScript 3. Массивы</h1>
	<h2>Массивы</h2>
	<h3>Создание и использование</h3>
	<p>Массивы предназначены для хранения коллекций данных, в т.ч. упорядоченных. Синтаксис создания массива:</p>
	<code class="listing">
		<span class="comment">// создание с помощью литерала</span><br />
		<span class="key">var</span> array1 = []; <span class="comment">// пустой массив</span><br />
		<span class="key">var</span> array2 = [1, 2, 3]; <span class="comment">// массив с элементами</span><br />
		<span class="key">var</span> array3 = [<span class="key">true</span>, 42, <span class="string">"dog"</span>]; <span class="comment">// массив с элементами разного типа</span><br />
		<br />
		<span class="comment">// создание массива в помощью new Array</span><br />
		<span class="key">var</span> array4 = <span class="var">new</span> <span class="key">Array</span>(); <span class="comment">// пустой массив</span><br />
		<span class="key">var</span> array5 = <span class="var">new</span> <span class="key">Array</span>(2); <span class="comment">// массив длиной 2 элемента</span><br />
		<span class="key">var</span> array6 = <span class="var">new</span> <span class="key">Array</span>(0.5); <span class="comment">// Error: Invalid array length</span><br />
		<span class="key">var</span> array7 = <span class="var">new</span> <span class="key">Array</span>(<span class="string">"2"</span>); <span class="comment">// массив длиной 1 элемент</span><br />
		<span class="key">var</span> array8 = <span class="var">new</span> <span class="key">Array</span>(1, <span class="string">"2"</span>, <span class="key">null</span>); <span class="comment">// массив с элементами разного типа</span><br />
	</code>
	<p>Помимо индексов массив имеет специальное свойство <b>length</b>, которое указывает на длину неразреженного массива.</p>
	<p>Доступ к элементам массива осуществляется с помощью квадратных скобок:</p>
	<code class="listing">
		<span class="key">var</span> days = [<span class="string">"Sunday"</span>, <span class="string">"Monday"</span>];<br />
		alert(days[0]);<br />
		alert(days[1]);<br />
		days[2] = <span class="string">"Tuesday"</span><br />
		alert(days[2]);<br />
	</code>
	<p>Массивы в JavaScript так же не имеют строгой типизации, т.е. могут содержать в себе разнородные данные, в том числе и другие массивы. Такие массивы называются многомерными.</p>
	<code class="listing">
		<span class="key">var</span> matrix = [<br />
		&nbsp; &nbsp; [1, 2, 3], <br />
		&nbsp; &nbsp; [4, 5, 6], <br />
		&nbsp; &nbsp; [7, 8, 9] <br />
		];<br />
		alert(matrix[0][0]);<br />
		alert(matrix[2][2]);<br />
	</code>
	<h3>Методы массивов</h3>
	<table class="methods">
		<tr>
			<th>toString()</th>
			<td>преобразует массив в строку</td>
		</tr>
		<tr>
			<th>pop()</th>
			<td>удаляет элемент c конца массива, возвращает удаленный элемент *</td>
		</tr>
		<tr>
			<th>push(<em>el1, el2, ...</em>)</th>
			<td>добавляет элемент(ы) в конец массива *</td>
		</tr>
		<tr>
			<th>shift()</th>
			<td>удаляет элемент c начала массива, возвращает удаленный элемент *</td>
		</tr>
		<tr>
			<th>unshift(<em>el1, el2, ...</em>)</th>
			<td>добавляет элемент(ы) в начало массива *</td>
		</tr>
		<tr>
			<th>indexOf(<em>val</em> [, fromIndex])</th>
			<td>возвращает индекс элемента со значением <b>val</b> или -1, если элемент не найден. Ищет с начала массива. Если задан <b>fromIndex</b>, то осуществляет поиск, начиная с заданной позиции и до конца массива. Если <b>fromIndex</b> отрицаетльный, то начальный индекс устанавливается с конца</td>
		</tr>
		<tr>
			<th>lastIndexOf(<em>val</em> [, fromIndex])</th>
			<td>возвращает индекс элемента со значением <b>val</b> или -1, если элемент не найден. Ищет с конца массива. Если задан <b>fromIndex</b>, то осуществляет поиск, начиная с заданной позиции и до начала массива</td>
		</tr>
		<tr>
			<th>join(<em>[separator]</em>)</th>
			<td>объединяет элементы массива в строку, в качестве разделителя использует <b>separator</b> или ","</td>
		</tr>
		<tr>
			<th>concat(<em>val1 [, val2 [, ...[, valN]]]</em>)</th>
			<td>возвращает массива, к которому справа добавлены элементы, переданные в качестве аргументов</td>
		</tr>
		<tr>
			<th>reverse()</th>
			<td>меняет порядок следования элементов массива на обратный *</td>
		</tr>
		<tr>
			<th>slice(<em>[begin [, end]]</em>)</th>
			<td>возвращает участок массива от элемента с индексом <b>begin</b> (или 0) и до <b>end</b> (или до конца массива)</td>
		</tr>
		<tr>
			<th>splice(<em>start [, deleteCount [, val1, val2, ...]]</em>)</th>
			<td>удаляет, начиная с позиции <b>start</b>, <b>deleteCount</b> элементов (или до конца массива), вставляет на их место элементы <b>valN</b></td>
		</tr>
		<tr>
			<th>sort(<em>[callback]</em>)</th>
			<td>сортирует массив по возрастанию, используя лексикографическое сравнение. Если задана <b>callback</b>, то использует её для определения порядка элементов</td>
		</tr>
		<tr>
			<th>forEach(<em>callback(val, [i, [arr]])</em> {<br />
&nbsp; &nbsp; // итератор<br />
});</th>
			<td>выполняет <b>callback</b> для каждого элемента. <b>Callback</b> принимает аргументами значение текущего элемента, его индекс и ссылку на массив. Замена для <b>for</b></td>
		</tr>
		<tr>
			<th>every(<em>callback(val, [i, [arr]])</em> {<br />
&nbsp; &nbsp; // условие<br />
});</th>
			<td>возвращает <b>true</b>, если все элементы массива удовлетворяют условию в <b>callback</b></td>
		</tr>
		<tr>
			<th>some(<em>callback(val, [i, [arr]])</em> {<br />
&nbsp; &nbsp; // условие<br />
});</th>
			<td>возвращает <b>true</b>, если хотя бы один элемент массива удовлетворяет условию в <b>callback</b></td>
		</tr>
		<tr>
			<th>filter(<em>callback(val, [i, [arr]])</em> {<br />
&nbsp; &nbsp; // условие<br />
});</th>
			<td>возвращает подмассив с элементами, для которых <b>callback</b> вернет <b>true</b></td>
		</tr>
		<tr>
			<th>find(<em>callback(val, [i, [arr]])</em> {<br />
&nbsp; &nbsp; // условие<br />
});</th>
			<td>возвращает первый элемент, для которго <b>callback</b> вернет <b>true</b></td>
		</tr>
		<tr>
			<th>includes(<em>val [, fromIndex]</em>)</th>
			<td>возвращает <b>true</b>, если <b>val</b> есть в массиве. Начинает поиск с <b>fromIndex</b></td>
		</tr>
		<tr>
			<th>map(<em>callback(val, [i, [arr]])</em> {<br />
&nbsp; &nbsp; // код<br />
});</th>
			<td>возвращает массив, в котором для каждого элемента исходного массива была выполнена <b>callback</b></td>
		</tr>
		<tr>
			<th>reduce(callback(result, val) {<br />
&nbsp; &nbsp; // return result<br />
}[, initVal]);</th>
			<td>Выполняет <b>callback</b> для каждого элемента массива, результат накапливает в <b>result</b>. Начальное значение <b>result</b> можно задать в <b>initVal</b>, иначе берется начальный элемент массива</td>
		</tr>
		<tr>
			<td colspan="2">* &ndash; метод меняет исходный массив</td>
		</tr>
	</table>
</body>
</html>