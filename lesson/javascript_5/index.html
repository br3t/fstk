<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8" />
	<title>Основы JavaScript 5. ООП@ Курс Frontend-разработки</title>
	<link rel="stylesheet" type="text/css" href="../../css/style.css" />
</head>
<body>
	<h1>Основы JavaScript 5. Объектно-ориентированное программирование</h1>
	<p>В основе объектно-ориентированного программированиия (ООП) лежат две сущности: <b>класс</b> и <b>объект</b>.</p>
	<p>Основные парадигмы ООП:</p>
	<ul>
		<li>абстракция</li>
		<li>инкапсуляция</li>
		<li>наследование</li>
		<li>полиморфизм</li>
	</ul>
	<h2>Глобальный объект</h2>
	<p>В JavaScript все переменные и функции, имеющие глобальную область видимости, являются свойствами специального объекта, который называется <b>глобальный объект</b>. В браузере этот объект доступен как <b>window</b>.</p>

	<h2>Порядок инициализации</h2>
	<p>Выполнение программы происходит в два этапа:</p>
	<ol>
		<li>этап подготовки</li>
		<li>этап выполнения</li>
	</ol>

	<h2>Лексическое окружение</h2>
	<p>Все переменные внутри функции являются свойствами специального внутреннего объекта <b>LexicalEnvironment</b>, который создаётся при её запуске.</p>

	<h3>Доступ ко внешним переменным</h3>
	<p>Функция имеет доступ не только к локальным, но и к глобальным переменных. При доступе к переменной она сначала ищется в <b>LexicalEnvironment</b> функции, а затем &mdash; в <b>LexicalEnvironment</b> того объекта, в котором была вызвана функция, пока переменная не будет обнаружена. Внешние по отношению к данной функции переменные хранятся в скрытом объекте <b>[[Scope]]</b>, который является ссылкой на <b>LexicalEnvironment</b>, в котором функция была создана.</p>

	<h3>Вложенные функции</h3>
	<p>Внутри функций можно создавать другие, вспомогательные функции. Такие функции так же, как и обычные переменные, будут иметь локальную область видимости для "функции-родителя". У таких функций будет свой <b>[[Scope]]</b>, состоящий из <b>LexicalEnvironment</b> "функции-родителя".</p>

	<h3>Свойства функции</h3>
	<p>Т.к. функция в JavaScript является объектом, то ей, как и любому объекту, можно добавлять свойства и методы. Такие свойства будут доступны везде, где будет доступна сама функция.</p>

	<h2>Преобразование объектов</h2>
	<p>Как и к другим типам данных к объектам может применяться одно из трёх преобразований типов: логическое, численное, строковое.</p>
	<p>Любой объект, даже пустой, при логическом преобразовании всегда возвращает <b>true</b>.</p>
	<p>При строковом преоборазовании выведется результат выполнения метода <b>toString</b>, если такой есть в объекте, а иначе - просто строка <b>[object Object]</b>. Созданный программистом метод <b>toString</b> может возвращать любое примитивное значение, причем не только строку, так что такое преобразование называется именно <em>строковым преобразованием</em>, а не <em>преобразованием к строке</em>.</p>
	<p>Для численного преобразования объекта используется метод <b>valueOf</b>, а если такого метода нет &mdash; то метод <b>toString</b>. Метод <b>valueOf</b> также может возвращать любой примитив, необязательно число. У большинства встроенных объектов метод <b>valueOf</b> отсутствует, поэтому для численного преобразования применяется метод <b>toString</b>.</p>

	<h2>Ключевое слово this</h2>
	<p>Ключевое слово <b>this</b> указывает на объект, который вызвал данную функцию. Если метод объекта использует <b>this</b>, то в таком случае this ссылаеся на сам этот объект.</p>

	<h2>Конструктор</h2>
	<p>Конструктором является любая функция, вызванная через <b>new</b></p>
	<code class="listing"><span class="key">function</span> <span class="name">Car</span>(name) {<br />
	&nbsp; &nbsp; this.name = name;<br />
	&nbsp; &nbsp; this.wheels = 4;<br />
	&nbsp; &nbsp; this.addWheel = <span class="key">function</span>(<span class="name">wheelNum</span>) {<br />
	&nbsp; &nbsp; &nbsp; &nbsp; this.wheels += wheelNum;<br />
	&nbsp; &nbsp; };<br />
}<br />
<br />
<span class="key">var</span> car = <span class="var">new</span> Car(<span class="string">"Mersedes"</span>);
		
	</code>
	<h3>Обработка return у функции-конструтора</h3>
	<p>По окончании своей работы функция-конструктор возвращает ссылку на вновь созданный объект. Но это поведение может меняться, если добавить <b>return</b> в функцию.</p>
	<p>Если <b>return</b> вернет примитив, то он не будет учитываться, т.е. функция-конструктор отработает так, как если бы <b>return</b> не было. Если <b>return</b> вернет объект, то функция вернет этот.</p>
	<p>Если в конструктор не нужно передавать никакие параметры, то его можно вызывать без скобок.</p>

	<h2>Дескрипторы</h2>
	<p>Помимо обычного создания свойств объекта есть ещё "продвинутое" &mdash; через метод <b>Object.defineProperty</b>. Метод принимает три параметра, третьим является <b>дескриптор</b> &mdash; объект-конфигурация вновь созданного свойства.</p>
	<code class="listing"><span class="key">var</span> car = {};<br />
car.color = <span class="string">"red"</span>; <span class="comment">// обычное добавление свойства</span><br /><br />
Object.defineProperty(car, <span class="string">"speed"</span>, { <span class="comment">// добавление свойства с помощью дескриптора</span><br />
&nbsp; &nbsp; value: 100, <span class="comment">// значение свойства</span><br />
&nbsp; &nbsp; configurable: <span class="var">true</span>, <span class="comment">// возможность удалять свойство (только в use strict)</span><br />
&nbsp; &nbsp; writable: <span class="var">true</span>, <span class="comment">// возможность изменять значение свойства (только в use strict)</span><br />
&nbsp; &nbsp; enumerable: <span class="var">true</span> <span class="comment">// "перечисляемость" свойства</span><br />
});<br />
Object.defineProperty(car, <span class="string">"carInfo"</span>, {<br />
&nbsp; &nbsp; get: <span class="key">function</span>() {<br />
&nbsp; &nbsp; &nbsp; &nbsp; return <span class="string">"My speed is "</span> + this.speed;<br />
&nbsp; &nbsp; },<br />
&nbsp; &nbsp; set: <span class="key">function</span>(value) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; this.speed = value;<br />
&nbsp; &nbsp; },<br />
});
	</code>
</body>
</html>



