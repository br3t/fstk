<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8" />
	<title>Основы тестирования 1@ Курс Frontend-разработки</title>
	<link rel="stylesheet" type="text/css" href="../../css/style.css" />
	<style>quote {padding-left: 50%;display: block;font: italic 0.8em/1.2em Verdana;}
	</style>
</head>
<body>
	<h1>Основы тестирования 1</h1>
	<quote>Когда пишешь код, думай о тесте.<br />
Когда пишешь тест, думай о коде.<br />
Когда ты думаешь о коде и тесте как о едином,<br />
тестирование просто, а код красив.</quote>
	<h2>Тестирование, его цели. Организация тестирования</h2>
	<p>Тестирование является важным этапом основных методологий разработки.</p>
	<code class="console">Требования -> Проектирование -> Разработка -> Тестирование -> Запуск</code>
	<p>Тестирование предшествует выпуску приложения в production и позволяет обнаружить и исправить большое количество ошибок. Исправить ошибки на этапе тестирования чаще всего дешевле и проще, чем обнаруженные на этапе внедрения.</p>
	<p>Этапы тестирования:</p>
	<ol>
		<li>Модульное тестирование &mdash; тестирование отдельных частей программы</li>
		<li>Интеграционное тестирование &mdash; тестирование взаимодействия частей программы</li>
		<li>Системное тестирование &mdash; тестирование работы приложения в целом и проверка требований, проверка интеграции с другими системами</li>
		<li>Приемочное тестирование &mdash; заключительное тестирование заказчиком приложения с вердиктом о принятии системы в эксплуатацию</li>
	</ol>
	<p>Для web-проектов выделяют также следующие типы тестирования:</p>
	<ul>
		<li>Функциональное тестирование</li>
		<li>Юзабилити тестирование сайта</li>
		<li>Нагрузочное тестирование сайтов</li>
		<li>Тестирование пользовательского интерфейса</li>
		<li>Тестирование на уязвимости</li>
		<li>Тестирование локализации</li>
	</ul>
	<p>По типу выполнения тестирование разделяют на:</p>
	<ul>
		<li>ручное</li>
		<li>автоматическое</li>
		<li>полуавтоматическое</li>
	</ul>

	<h2>Unit тестирование</h2>
	<p><b>Модульное тестирование (Unit тестирование)</b> &mdash; это проверка работоспособности и правильной работы отдельных частей (модулей) программы. Модуль для тестирования &mdash; это не обязательно модуль программы, чаще всего это отдельная "программная единица", поддающая тестированию: функция или метод какого-либо класса/объекта.</p>
	<p><b>Модульный тест</b> &mdash; это совокупность данных, подаваемых на вход тестируемой функции и совокупность результатов, ожидаемых от выполнения функции. Если фактические результаты выполнения совпадают с ожидаемыми, то такой тест считается пройденным. Прохождение теста подтверждает поведение, предполагаемое разработчиком. Если результаты не совпадают, то тест считается проваленным и это сигнал для разработчика, что нужно искать и исправлять ошибку.</p>
	<p>Модульное тестирование &mdash; комплексная задача, в свою очередь состоящая из этапов:</p>
	<ul>
		<li>определение объемов тестирования</li>
		<li>выбор инструментария и его настройка</li>
		<li>подготовка кода (декомпозиция, выделение чистых функций)</li>
		<li>подготовка и написание тестов</li>
		<li>запуск тестов</li>
		<li>обработка результатов тестов</li>
	</ul>
	<h3>Преимущества модульного тестирования</h3>
	<ul>
		<li>поощрение проведения рефакторинга</li>
		<li>упрощение интеграции</li>
		<li>тесты как документация</li>
		<li>улучшение интерфейса через абстрагирование</li>
		<li>улучшение качества кода (за счет "двойной записи")</li>
		<li>гарантия того, что код делает именно то, что заявлено</li>
		<li>скорость нахождения багов</li>
		<li>возможность предупредить трудновоспроизводимые баги</li>
		<li>удобная координация работы при распределенной разработке</li>
		<li>возможность оперативно получить информацию о работоспособности системы в целом</li>
	</ul>
	<h3>Проблемы использования модульного тестирования</h3>
	<ul>
		<li>дополнительные затраты ресурсов на написание и поддержку тестов</li>
		<li>одних модульных тестов недостаточно</li>
		<li>модульные тесты не могут учесть внешних факторов</li>
		<li>модульные тесты не найдут ошибки в том коде, для которого они не написаны</li>
		<li>необходимость поддержания тестов в состоянии, актуальном состоянию кода</li>
		<li>необходимость поддержания mock-объектов в актуальном состоянии</li>
		<li>слишком сложный код для тестирования</li>
		<li>необходимость внедрения культуры тестирования</li>
		<li>модульное тестирование затруднено в случаях, когда невозможно точно предвидеть результат</li>
		<li>нет смысла внедрять тестирование только для отчетности, не выполняющее прямого назначения</li>
		<li>практически невозможно писать тесты для старого кода, который нельзя переписать</li>
	</ul>
	<h3>Принципы тестирования</h3>
	<ul>
		<li>тесты помогают отловить баги, но не гарантируют полное отсутствие последних</li>
		<li>нельзя написать исчерпывающие тесты</li>
		<li>тестирование тем эффективней, чем раньше оно начато</li>
		<li>объем тестов отдельных модулей должен быть пропорционален объему обнаруженных багов</li>
		<li>тесты, которые долго успешно выполняются следует пересматривать после рефакторинга, который мог повлечь возникновение ошибок на новых наборах данных </li>
	</ul>
	<p>Код тестов вместе с системой из запуска обычно размещают в отдельной папке. Сам процесс запуска тестов и проверки результатов максимально упрощают.</p>
	<p>Тесты пишет разработчик, так как он точно понимает, какое поведение ожидается от того или иного модуля. Следует избегать написания разработчиком и кода, и тестов для этого кода, потому что в этом случае возможен вариант, когда тесты "подстраиваются" под написанный код.</p>

	<h2>TDD техника</h2>
	<p>Следуя принципу "раньше начали писать тесты &mdash; получили меньше багов в production" была разработана техника <b>разработки через тестирование (TDD, test-driven development)</b>. При использовании этой техники сначала определяются с необходимым функционалом, затем пишутся тесты, проверяющие соблюдение этого функционала, а затем только код, этот функционал реализующий.</p>
	<code class="console">Требования -> Проектирование -> Тестирование -> Разработка -> Запуск</code>
	<p>Таким образом, в какой-то момент времени у разработчика есть только тесты, но нет кода, который эти тесты покрывают, а потому все тесты провальные. По мере написания кода все больше и польше тестов становится пройденными. В момент, когда все модульные тесты пройдены, можно считать, что система удовлетворяет поставленным условиям.</p>
	<h3>Схема разработки по методике TDD</h3>
	<p><img src="tdd.png"></p>
	<p>Методика тесно связана с принципами <em>«делай проще, дружище» (англ. keep it simple, stupid, KISS)</em> и <em>«вам это не понадобится» (англ. you ain’t gonna need it, YAGNI)</em>. Преимуществом данного метода является то, что при написании кода разработчик не задумавается о красоте и элегантности решения, он пишет код только для того, чтобы последний прошел тесты. И только после того, как все тесты пройдены, можно заниматься рефакторингом. Методика обязывает писать тесты на весь функционал системы, ведь для чего не будет написано тестов, для того не будет и написано кода.</p>
	<p>Идея того, что новый тест проходит или не проходит, ясно показывает, что тест реально что-то проверяет, а не сделан "для галочки".</p>
	<p>Несмотря на то, что кода в итоге пишется значительно больше, время на разработку уменьшается, т.к. большинство багов устраняется прямо на этапе написания кода и время на отладку уменьшается. Внесение изменений в функциональность или в код сразу же отразится на тестах, потому у разработчика будет возможность оперативно отреагировать на эти изменения. Соответсвенно, рефакторинг благодаря тестам покажет свою успешность или неуспешность.</p>

	<h2>BDD техника</h2>

	
</body>
</html>