<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8" />
	<title>Основы JavaScript 4.1. Встроенные инструменты@ Курс Frontend-разработки</title>
	<link rel="stylesheet" type="text/css" href="../../css/style.css" />
	<style>
		.methods {
			border: 1px solid #000;
			border-collapse: collapse;
			width: 100%;
		}
		.methods tr:nth-child(2n) {
			background: #FFF;
		}
		.methods td,
		.methods th {
			border: 1px solid #000;
			padding: 5px 7px;
			text-align: left;
			vertical-align: top;
		}
		.methods th {
			width: 400px;
			font-family: Menlo, "Lucida Sans Typewriter", monospace;;
		}
	</style>
</head>
<body>
	<h1>Основы JavaScript 4.1. Встроенные инструменты</h1>
	<h2>Работа со строками</h2>
	<p>Длина строки доступна с помощью свойства <b>length</b>. Несмотря на то, что отдельный символ строки можно получить с помощью квадратных скобок, что делает строки похожими на массив символов, изменением <b>length</b> нельзя обрезать строку.</p>
	<code class="listing">
		<span class="key">var</span> language = <span class="string">'javascript'</span>;<br />
		alert(language.length); <span class="comment">// 10</span><br />
		language.length = 3;<br />
		alert(language.length); <span class="comment">// 10, нельзя изменить длину</span><br />
		alert(language[0]); <span class="comment">// "j", отсчет символов начинается с нуля</span><br />
	</code>
	<p>Для работы со строками в JavaScript существуют следующие методы:</p>
	<table class="methods">
		<tr>
			<th>charAt(<em>n</em>)</th>
			<td>возвращает символ с индексом <b>n</b>. Аналог <b>[n]</b></td>
		</tr>
		<tr>
			<th>charCodeAt(<em>n</em>)</th>
			<td>возвращает Unicode-код символа в позиции <b>n</b></td>
		</tr>
		<tr>
			<th>String.fromCharCode(<em>code</em>)</th>
			<td>возвращает символ по его Unicode-коду <b>code</b></td>
		</tr>
		<tr>
			<th>indexOf(<em>subString [, start]</em>)</th>
			<td>возвращает позицию найденной подстроки или -1, если подстрока не найдена. В <b>start</b> можно указать, с какой позиции начинать поиск</td>
		</tr>
		<tr>
			<th>toUpperCase()</th>
			<td>перевод строки в верхний регистр</td>
		</tr>
		<tr>
			<th>toLowerCase()</th>
			<td>перевод строки в нижний регистр</td>
		</tr>
		<tr>
			<th>substr(<em>start [, size]</em>)</th>
			<td>возвращает подстроку, начинающуюся со <b>start</b>, и размером <b>size</b> или до конца строки</td>
		</tr>
		<tr>
			<th>substring(<em>start [, finish]</em>)</th>
			<td>возвращает подстроку, начинающуюся со <b>start</b>, и до <b>finish</b>, не включая её, или до конца строки. Индексы, выходящие за диапазон строки урезает, при <b>finish < start</b> меняет аргументы местами</td>
		</tr>
		<tr>
			<th>slice(<em>start [, finish]</em>)</th>
			<td>работает аналогично <b>substring</b>, но отрицательные индексы отсчитываются с конца строки</td>
		</tr>
	</table>

	<h2>Работа с числами</h2>
	<p>Способы записи чисел:</p>
	<ul>
		<li>обычная запись <b>n = 10;</b></li>
		<li>"научная запись" <b>n = 1e1;</b></li>
		<li>в восьмиричной системе <b>n = 012;</b></li>
		<li>в шестнадцатиричной системе <b>n = 0xA;</b></li>
	</ul>
	<p>Особенностью чисел в Javascript является неточность вычислений (например, <b>0.1 + 0.2 != 0.3</b>), связанная с тем, что некоторые дробные числа не могут быть представлены в двоичной системе в виде конечной дроби. Следует помнить об этом и по возможности избегать требующих точности вычислений с дробными числами, заменяя их на операции с целыми.</p>
	<p>Для работы с числами в JavaScript существуют следующие функции и методы:</p>
	<table class="methods">
		<tr>
			<th>isNaN(<em>n</em>)</th>
			<td>проверяет <b>n</b> на <b>NaN</b></td>
		</tr>
		<tr>
			<th>isFinite(<em>n</em>)</th>
			<td>проверяет, конечно ли <b>n</b>. Возвращает <b>false</b> для <b>Infinity</b>, <b>-Infinity</b> и <b>NaN</b></td>
		</tr>
		<tr>
			<th>parseInt(<em>n [, base]</em>)</th>
			<td>посимвольно преобразует <b>n</b> в целое число. Если указан <b>base</b>, то интерпретирует <b>n</b> как число в base-ричной системе исчисления. <b>base</b> должно быть больше в пределах 2..36, иначе вернётся <b>NaN</b></td>
		</tr>
		<tr>
			<th>parseFloat(<em>n</em>)</th>
			<td>посимвольно преобразует <b>n</b> в число с дробной частью</td>
		</tr>
		<tr>
			<th>.toString(<em>base</em>)</th>
			<td>преобразует число в строку-число в base-ричной системе исчисления. <b>base</b> должно быть больше в пределах 2..36, иначе сгенерируется ошибка </td>
		</tr>
		<tr>
			<th>.toFixed(<em>precision</em>)</th>
			<td>возвращает строку-число, округленное до <b>precision</b> знаков после запятой. Если значимых значений нет, то дополняет нулями</td>
		</tr>
	</table>
	<h3>Математические функции</h3>
	<p>Для выполнения математических операций используются методы специального объекта <b>Math</b>:</p>
	<table class="methods">
		<tr>
			<th>floor(<em>n</em>)</th>
			<td>округляет <b>n</b> до целого вниз</td>
		</tr>
		<tr>
			<th>ceil(<em>n</em>)</th>
			<td>округляет <b>n</b> до целого вверх</td>
		</tr>
		<tr>
			<th>round(<em>n</em>)</th>
			<td>округляет <b>n</b> до целого по правилам округления</td>
		</tr>
		<tr>
			<th>abs(<em>n</em>)</th>
			<td>вычисляет абсолютное значение для <b>n</b></td>
		</tr>
		<tr>
			<th>sin(<em>angle</em>)</th>
			<td>вычисляет синус угла <b>angle</b>, заданного в радианах</td>
		</tr>
		<tr>
			<th>cos(<em>angle</em>)</th>
			<td>вычисляет косинус угла <b>angle</b>, заданного в радианах</td>
		</tr>
		<tr>
			<th>tan(<em>angle</em>)</th>
			<td>вычисляет тангенс угла <b>angle</b>, заданного в радианах</td>
		</tr>
		<tr>
			<th>asin(<em>n</em></th>
			<td>вычисляет арксинус <b>n</b></td>
		</tr>
		<tr>
			<th>acos(<em>n</em></th>
			<td>вычисляет арккосинус <b>n</b>, результат в раианах</td>
		</tr>
		<tr>
			<th>atan(<em>n</em>)</th>
			<td>вычисляет арктангенс <b>n</b></td>
		</tr>
		<tr>
			<th>atan2(<em>x, y</em>)</th>
			<td>вычисляет угол до точки (x, y)</td>
		</tr>
		<tr>
			<th>min(<em>e1, e2, ...</em>)</th>
			<td>возвращает минимальное значение из аргументов</td>
		</tr>
		<tr>
			<th>max(<em>e1, e2, ...</em>)</th>
			<td>возвращает максимальное значение из аргументов</td>
		</tr>
		<tr>
			<th>pow(<em>n, exp</em>)</th>
			<td>вычисляет <b>n</b> в степени <b>exp</b></td>
		</tr>
		<tr>
			<th>sqrt(<em>n</em>)</th>
			<td>вычисляет квадратный корень из <b>n</b></td>
		</tr>
		<tr>
			<th>log(<em>n</em>)</th>
			<td>вычисляет натуральный логарифм от <b>n</b></td>
		</tr>
		<tr>
			<th>exp(<em>n</em>)</th>
			<td>вычисляет <b>e</b> (экспонента) в степени <b>n</b></td>
		</tr>
		<tr>
			<th>random()</th>
			<td>возвращает псевдослучайное число в диапазоне <b>[0;1)</b></td>
		</tr>
	</table>
	<p>Объект <b>Math</b> также содержит в себе математические константы:</p>
	<ul>
		<li>число Пи: <b>Math.PI = 3.141592653589793</b></li>
		<li>экспоненту: <b>Math.E = 2.718281828459045</b></li>
	</ul>
	<p>и некоторые заранее вычисленные величины:</p>
	<ul>
		<li>квадратный корень из 2: <b>Math.SQRT2 == Math.sqrt(2)</b></li>
		<li>квадратный корень из &frac12;: <b>Math.SQRT1_2 == Math.sqrt(.5)</b></li>
	</ul>

	<h2>Работа с датой и временем</h2>
	<p>Работы с датой и временем в JavaScript осуществляется при помощи объекта <b>Date</b>:</p>
	<code class="listing">
		<span class="comment">// получаем объект текущего момента времени</span><br />
		<span class="key">var</span> dateNow = <span class="key">new</span> Date();<br />
		alert(dateNow); <span class="comment">// <script>document.write(new Date());</script></span><br /><br />
		
		<span class="comment">// получаем текущий timestamp в миллисекундах</span><br />
		<span class="key">var</span> dateNow2 = Date.now();<br />
		alert(dateNow2); <span class="comment">// <script>document.write(Date.now());</script></span><br /><br />

		<span class="comment">// задаем дату в виде миллисекунд, прошедших после после 1 января 1970 года</span><br />
		<span class="key">var</span> dateMilliseconds = <span class="key">new</span> Date(60 * 1000);<br />
		alert(dateMilliseconds); <span class="comment">// Thu Jan 01 1970 02:01:00 GMT+0200 (MSK)</span><br /><br />

		<span class="comment">// задаем дату в виде строки в формате RFC2822</span><br />
		<span class="key">var</span> dateString = <span class="key">new</span> Date(<span class="string">"Wed Oct 11 2017 12:00:00 GMT+0300 (EEST)"</span>);<br />
		alert(dateString); <span class="comment">// Wed Oct 11 2017 12:00:00 GMT+0300 (EEST)</span><br /><br />

		<span class="comment">// задаем дату в виде строки в формате ISO 8601 Extended</span><br />
		<span class="key">var</span> dateString2 = <span class="key">new</span> Date(<span class="string">"2017-10-12T19:30:00+03:00"</span>); <br />
		alert(dateString2); <span class="comment">// Thu Oct 12 2017 19:30:00 GMT+0300 (EEST)</span><br /><br />

		<span class="comment">// задаем дату в виде массива в формате <b>год, месяц, число, часы, минуты, секунды</b></span><br />
		<span class="key">var</span> dateArguments = <span class="key">new</span> Date(2018, 0, 1, 12, 0, 0);<br />
		alert(dateArguments); <span class="comment">// Mon Jan 01 2018 12:00:00 GMT+0200 (MSK)</span><br />
	</code>

	<h2>Работа с JSON</h2>
	<p>JSON &mdash; универсальный формат хранения данных. Для работы с этим форматом в JavaScript используют объект <b>JSON</b> с двумя методами: для извлечения данных из JSON и для преобразования данных в JSON.</p>
	<code class="listing">
		<span class="comment">// извлечение данных</span><br />
		<span class="key">var</span> fromJsonString = <span class="string">'[1, "a", {"b": 2}]'</span>;<br />
		<span class="key">var</span> fromJsonObject = JSON.parse(fromJsonString); <span class="comment">// в переменную попадает распаршенный массив <b>[1, "a", {"b": 2}]</b></span>
	</code>
	<p>С помощью второго наобязательного параметра-функции можно при парсинге обрабатывать свойства результирующего объекта:</p>
	<code class="listing">
		<span class="key">var</span> fromJsonString2 = <span class="string">'{"integer": 1.1, "float": 2.2, "more": {"integer": 3.3}}'</span>;<br />
		<span class="key">var</span> fromJsonObject2 = JSON.parse(fromJsonString2, <span class="key">function</span> (key, value) {<br />
		&nbsp; &nbsp; <span class="var">if</span>(key==<span class="string">"integer"</span>) {<br />
		&nbsp; &nbsp; &nbsp; &nbsp; <span class="var">return</span> parseInt(value);<br />
		&nbsp; &nbsp; }<br />
		&nbsp; &nbsp; <span class="var">return</span> value;<br />
		});<br />
		<span class="comment">// fromJsonObject2={integer: 1, float: 2.2, more: {integer: 3}}</span>
	</code>
	<p>Данная функция работает рекурсивно, т.е. преобразуются все совпадения свойств, в т.ч. и вложенных.</p>
	<p>Для отправки на сервер, сохранения в localStorage и т.д. используют преобразование данных в JSON-строку с помощью метода <b>stringify</b>. Такой процесс называется <b>сериализацией</b></p>
	<code class="listing">
		<span class="key">var</span> toJsonObject = {<span class="string">"name"</span>: <span class="string">"Bill"</span>, <span class="string">"age"</span>: 42};<br />
		<span class="key">var</span> toJsonString = JSON.stringify(toJsonObject);<br />
		<span class="comment">// toJsonString = '{"name":"Bill","age":42}'</span>
	</code>
	<p>С помощью второго необязательного параметра можно указать (с помощью массива или функции), какие свойства необходимо сериализовать.</p>
	<code class="listing">
		<span class="key">var</span> toJsonObject2 = {<span class="string">"name"</span>: <span class="string">"Bill"</span>, <span class="string">"age"</span>: 42};<br />
		<span class="key">var</span> toJsonString2 = JSON.stringify(toJsonObject, [<span class="string">"name"</span>]);<br />
		<span class="comment">// toJsonString2 = '{"name":"Bill"}'</span>
	</code>
	<p>Третий необзательный параметр метода <b>stringify</b> позволяет отформатировать выходную строку, добавив указанное количество пробелов или указанную строку</p>
	<code class="listing">
		<span class="key">var</span> toJsonObject3 = {<span class="string">"name"</span>: <span class="string">"Bill"</span>, <span class="string">"age"</span>: 42};<br />
		<span class="key">var</span> toJsonString3 = JSON.stringify(toJsonObject, "", 4);<br />
		<span class="comment">/* toJsonString3 = <br />
		{<br />
    	&nbsp; &nbsp; "name": "Bill",<br />
    	&nbsp; &nbsp; "age": 42<br />
		}<br />
		*/</span>
	</code>

	<h2>Строгий режим use strict</h2>
	<p>В своем развитии JavaScript, при введнии новых возможностей, старался максимально сохранить совместимость старого кода. До того момента, когда синтаксис привели к стардантизированному виду, было написано столько сайтов, использующих устаревшие возможности или устаревший синтаксис, что нельзя было просто отказаться от этого старого кода. Потому в ES5 была введена специальная директива <b>use strict</b>, которая показывает интерпретатору, что использующий ее код написан с соблюдением стандартов.</p>
	<code class="listing"><span class="string">"use strict"</span>;<br />
<span class="comment">// вызовет ошибку при попытке создания переменной без var</span><br>
myVar = 0;<br /><br />
<span class="comment">// вызовет ошибку при попытке использования with</span><br />
<span class="key">var</span> user = {};<br />
<span class="var">with</span>(user) {<br />
&nbsp; &nbsp; name = <span class="string">"Petro"</span>;<br />
}<br /><br />
<span class="comment">// вызовет ошибку при попытке объявить свойство более 1 раза</span><br />
user = {<br />
&nbsp; &nbsp; name: <span class="string">"Ivan"</span>,<br />
&nbsp; &nbsp; name: <span class="string">"Petro"</span><br />
};<br /><br />
<span class="comment">// вызовет ошибку при попытке создания функции с одинаковыми параметрами</span><br />
<span class="key">function</span> <span class="name">rename</span>(name, name, surName) {<br />
&nbsp; &nbsp; <span class="string">"use strict"</span>;<br />
&nbsp; &nbsp; this.name = name;<br />
&nbsp; &nbsp; this.surName = surName;<br />
}<br /><br />
<span class="comment">// вызовет ошибку при попытке использования чисел в восьмиричной нотации</span><br />
<span class="key">var</span> today = 013;

</code>

	<h2>Куки</h2>
	<p>Куки &mdash; это текстовые файлы, которые сайты сохраняют на компьютере пользователя. При повторном заходе на сайт последний может "узнать" пользователя по содержимому куки.</p>
	<p>В JavaScript куки доступны через <b>document.cookie</b>. При обращении к этому свойству оно выводит строку, в которой переменные перечислены через <b>точку с запятой (;)</b>, название переменной и ее значение разделены знаком <b>равно (=)</b>. При присваивании <b>document.cookie</b> строки создается новая переменная и добавляется в конец списка куки.</p>
	<code class="listing">alert(document.cookie); <span class="comment">// test=test; test2=test; test3=test</span><br />
document.cookie = <span class="string">"test4=test";</span><br />
alert(document.cookie); <span class="comment">// test=test; test2=test; test3=test; test4=test</span>
	</code>
	<p>Так как при чтении куки стоит задача получения значения конкретной переменной, то приходится либо писать дополнительный код для парсинга <b>document.cookie</b>, либо воспользоваться готовой функцией:</p>
	<code class="listing"><span class="key">function</span> <span class="name">getCookie</span>(name) {<br />
&nbsp; &nbsp; <span class="key">var</span> matches = document.cookie.match(<span class="var">new</span> RegExp(<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="string">"(?:^|; )"</span> + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, <span class="string">'\\$1'</span>) + <span class="string">"=([^;]*)"</span><br />
&nbsp; &nbsp; ));<br />
&nbsp; &nbsp; <span class="var">return</span> matches ? decodeURIComponent(matches[1]) : undefined;<br />
}</code>
	<p>Запись куки тоже не делается прямым присваиванием, т.к. чаще всего помимо значения необходимо передать дополнительные параметры для переменной.</p>
	<code class="listing"><span class="key">function</span> <span class="name">setCookie</span>(name, value, options) {<br />
&nbsp; &nbsp; options = options || {};<br /><br />
&nbsp; &nbsp; var expires = options.expires;<br /><br />
&nbsp; &nbsp; <span class="var">if</span> (<span class="var">typeof</span> expires == <span class="string">"number"</span> &amp;&amp; expires) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="key">var</span> d = <span class="var">new</span> Date();<br />
&nbsp; &nbsp; &nbsp; &nbsp; d.setTime(d.getTime() + expires * 1000);<br />
&nbsp; &nbsp; &nbsp; &nbsp; expires = options.expires = d;<br />
&nbsp; &nbsp; }<br />
&nbsp; &nbsp; <span class="var">if</span> (expires &amp;&amp; expires.toUTCString) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; options.expires = expires.toUTCString();<br />
&nbsp; &nbsp; }<br /><br />
&nbsp; &nbsp; value = encodeURIComponent(value);<br /><br />
&nbsp; &nbsp; <span class="key">var</span> updatedCookie = name + <span class="string">"="</span> + value;<br /><br />
&nbsp; &nbsp; <span class="var">for</span> (<span class="key">var</span> propName <span class="var">in</span> options) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; updatedCookie += <span class="string">"; "</span> + propName;<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="key">var</span> propValue = options[propName];<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="var">if</span> (propValue !== <span class="var">true</span>) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updatedCookie += <span class="string">"="</span> + propValue;<br />
&nbsp; &nbsp; &nbsp; &nbsp; }<br />
&nbsp; &nbsp; }<br /><br />
&nbsp; &nbsp; document.cookie = updatedCookie;<br />
}	
	</code>
	<p>Функция принимает три параметра: имя переменной, значение и опции. В опциях указывается домен (domain) и путь (path), для которых доступна переменная, время жизни (expires) и доступ по https (secure).</p>

	<h2>Ошибки и их обработка</h2>
	<p>В программировании на JavaScript существует три типа ошибок:</p>
	<ul>
		<li><b>синтаксические</b> &mdash; связанные с пропуском операторов, скобок, пробелов, в целом &mdash; с неправильным использованием синтаксиса</li>
		<li><b>времени выполнения</b> &mdash; связанные с неправильным использованием операторов, переменных, свойств или методов объектов</li>
		<li><b>логические</b> &mdash; возникающие, когда программа работает, но работает неправильно и результат работы программы не тот, который ожидается</li>
	</ul>
	<p>Ошибки в логике программы хуже поддаются обнаружению именно в связи с тем, что программа продолжает свою работу. При возникновении синтаксической ошибки или ошибки времени выполнения  программа чаще всего "крашится" и выкидывает сообщение с ошибкой в консоль, в результате чего проблему можно локализовать и решить.</p>
	<h3>Основные типы ошибок</h3>
	<ul>
		<li><b>SyntaxError</b> - ошибка синтаксиса, например, пропуск символа <tt>var i = {;</tt></li>
		<li><b>ReferenceError</b> - ошибка ссылки, например, обращение к несуществующей переменной <tt>a++</tt></li>
		<li><b>RangeError</b> - ошибка выхода за пределы диапазона, например, преобразование числа к недопустимой системе исчисления <tt>(1).toString(37)</tt></li>
		<li><b>TypeError</b> - ошибка неправильного использования типа, например, запуск несуществующего метода <tt>var a = {};a.a();</tt></li>
	</ul>
	<h3>Перехват ошибок</h3>
	<p>Перехват ошибок осуществляется с помощью конструкции <tt>try..catch</tt></p>
	<code class="listing"><span class="var">try</span> {<br />
&nbsp; &nbsp; bad_code();<br />
} <span class="var">catch</span>(e) {<br />
&nbsp; &nbsp; console.log(<span class="string">"Возникла ошибка "</span>, e);<br />
}</code>
	<p>Использование <tt>try..catch</tt> позволяет избежать полного прекращения работы скрипта, т.е. если ошибка возникла внутри этого блока, то код за пределами блока продолжит выполнение. Перехват возможен только для ошибок времени выполнения, синтаксические ошибки прекратят работу скрипта в любом случае.</p>
	<p>Нет необходимости заворачивать вызов каждой функции в <tt>try..catch</tt>. Используйте её только в тех случаях, если предполагается изменение поведения функции, чтобы это изменение не вызвало поломку всей программы, либо тогда, когда вы не можете быть уверены в содержимом каких-либо объектов, например, при манипуляции с элементами DOM на странице, получении данных с сервера или пользовательского ввода.</p>
	<h3>Информация об ошибке</h3>
	<p>При возникновении ошибки в блок <b>catch</b> попадает объект ошибки под именем, указанным в качестве аргумента. Если блок обработки ошибки не содержит никакой сложной логики и большого количества строк кода, то в качестве имени аргумента допустимо использовать просто <b>e</b>. Для примера выше объект ошибки будет иметь следующий вид:</p>
	<code class="listing">{<br />
&nbsp; &nbsp; name: <span class="string">"ReferenceError"</span>,<br />
&nbsp; &nbsp; message: <span class="string">"bad_code is not defined"</span>,<br />
&nbsp; &nbsp; stack: <span class="string">"ReferenceError: bad_code is not defined↵    at file:///.../javascript_4/index_1.html:370:5"</span><br />
}</code>
	<p>В свойстве <b>name</b> содержится тип ошибки, в <b>message</b> &mdash; содержимое ошибки, а в <b>stack</b> &mdash; порядок вызова функций до возникновения ошибки, а также название файла и номер строки кода, вызвавшего возникновение ошибки.</p>
	<h3>Блок finally</h3>
	<p>У конструкции <tt>try..catch</tt> есть необязаетльный блок <tt>finally</tt>, используемый для кода, который должен выполниться независимо от того, возникла ошибка или нет. Синтаксис:</p>
		<code class="listing"><span class="var">try</span> {<br />
&nbsp; &nbsp; bad_code();<br />
} <span class="var">catch</span>(e) {<br />
&nbsp; &nbsp; console.log(<span class="string">"Возникла ошибка "</span>, e);<br />
} <span class="var">finally</span> {<br />
&nbsp; &nbsp; console.log(<span class="string">"Вот так вот"</span>);<br />
}</code>
	<p>Поведение "выполниться в любом случае" справедливо даже для случаев, когда блок <tt>try..catch</tt> находится в какой-то функции и внутри блока есть <tt>return</tt>.</p>
	<code class="listing"><span class="key">function</span> <span class="name">provideData</span>() {<br />
&nbsp; &nbsp; <span class="key">var</span> connect;<br />
&nbsp; &nbsp; <span class="var">try</span> {<br />
&nbsp; &nbsp; &nbsp; &nbsp; connect = server.connect();<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="key">var</span> data = connect.getData();<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="var">return</span> data;<br />
&nbsp; &nbsp; } <span class="var">catch</span>(e) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; console.log(<span class="string">"Can`t get data from server"</span>);<br />
&nbsp; &nbsp; } <span class="var">finally</span> {<br />
&nbsp; &nbsp; &nbsp; &nbsp; connect.close();<br />
&nbsp; &nbsp; }<br />
}</code>
	<h3>Использование собственных ошибок</h3>
	<p>При обработке ошибок, связанных с обработкой "внешних" данных (данные сервера, пользовательский ввод, DOM-элементы страницы) может возникнуть необходимость сгенерировать собственную ошибку для дальнейшего проброса обработчику ошибок. Для этого используют оператор <b>throw</b>. Для корректной обработки ошибки в качестве аргумента для <tt>throw</tt> передают объект ошибки, который можно создать либо с помощью конструктора <tt>Error</tt>, либо с помощью более специфических конструкторов <tt>SyntaxError, ReferenceError, RangeError</tt>:</p>
	<code class="listing"><span class="var">throw new</span> Error(<span class="string">"Data is wrong!"</span>);</code>

	<h2>Регулярные выражения</h2>
	<p>Регулярные выражения &mdash; мощное средство поиска строк.</p>
	<p>Для регулярных выражений используются:</p>
	<ul>
		<li>методы строк: <tt>search</tt> (возвращает индекс) и <tt>match</tt> (возвращает результаты)</li>
		<li>методы RegExp: <tt>test</tt> (проверка вхождения) и <tt>exec</tt> (возвращает результаты)</li>
	</ul>
	<p>Флаги:</p>
	<ul>
		<li><b>i</b> &mdash; игнорировать регистр</li>
		<li><b>g</b> &mdash; глобальный поиск</li>
		<li><b>m</b> &mdash; многострочный режим</li>
	</ul>
	<p></p>
</body>
</html>